variables:
  AMBIENTE:
    value: "QA"
    options:
      - "Produccion"
      - "QA"
    description: "Seleccionar que ambiente requieres desplegar, por defecto en qa"
  RELEASE_CANDIDATE:
    description: "Ingresar que versi칩n se debe desplegar en producci칩n, solo es necesario si el valor de AMBIENTE es 'Produccion'"

cache:
  key: "$CI_COMMIT_REF_SLUG"
  paths:
    - .m2/repository


stages:
    - setup
    - build
    - test
    - analitycs
    - release
    - delivery
    - deploy

#include:
#   - template: Jobs/Code-Quality.gitlab-ci.yml
#  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
#  - template: Jobs/SAST.gitlab-ci.yml
#  - template: Jobs/Secret-Detection.gitlab-ci.yml
#  - template: Jobs/Build.gitlab-ci.yml
#  - template: Jobs/Container-Scanning.gitlab-ci.yml

prepare:
    stage: setup
    image: alpine:latest
    script:
        - printenv | sort 
        - echo "CURRENT_DATE=$(date +%Y%m%d%H%M%S)" > setup.env
        - cat setup.env
    artifacts:
        reports:
            dotenv: setup.env
    rules:
        - if: '$CI_COMMIT_BRANCH == "release" && $AMBIENTE == "QA"'
#          when: manual
#        - when: never



Build:
  stage: build
  image: node:20-alpine
  variables:  
        BRANCH_RELEASE: release 
  before_script:
    - apk add --no-cache curl git zip jq    
  script:
    # Lllama secure files_   
    - npm cache clean --force    
    - npm install   
    - npm install -g @angular/cli
    - ng build
    - zip -r build.zip dist
    - pwd
    - ls -li
    - export VERSION=$(jq -r '.version' package.json)
    - echo "RELEASE_CANDIDATE=RC-V${VERSION}-${CURRENT_DATE}" > build.env
    - echo "VERSION=${VERSION}" >> build.env
    - cat build.env
  artifacts:
    paths:
      - build.zip
    expire_in: 10 min
  needs:
    - prepare
  rules:      
      - if: '$CI_COMMIT_BRANCH == "release" && $AMBIENTE == "QA"'


TestingApp:
    stage: test
    image: node:20.15
    variables:
        BRANCH_RELEASE: release     
    before_script:
        - echo $RELEASE_CANDIDATE 
        - apt-get install git wget gnupg
        - wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -
        - sh -c 'echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google-chrome.list'
        - apt update
        - apt install -y google-chrome-stable
    script: 
        - npm install -g @angular/cli
        - npm install karma --save-dev
        - npm install karma-junit-reporter --save-dev
        - npm install karma-coverage-istanbul-reporter  --save-dev
        - ng test --karma-config=karma.conf.js --watch=false --browsers=ChromeHeadlessNoSandbox --code-coverage
    artifacts: 
        reports:
            junit:
                - test-results/junit.xml 
    needs:
      - prepare
    rules:
        - if: '$CI_COMMIT_BRANCH == "release" && $AMBIENTE == "QA"'

stagging:
    stage: release
    image: alpine:latest
    before_script:
        - echo $RELEASE_CANDIDATE 
        - apk add --no-cache git
        - git config user.email '$GITLAB_USER_EMAIL'
        - git config user.name '$GITLAB_USER_LOGIN'
        - git config --global http.sslVerify "false"
    script:
        - git remote set-url origin "https://$GITLAB_USER_LOGIN:$GITLAB_TOKEN@$CI_SERVER_HOST/$CI_PROJECT_PATH.git"
        - git tag -a ${RELEASE_CANDIDATE} -m "Version creado desde CICD"
        - git push origin ${RELEASE_CANDIDATE}
    after_script: 
        - echo "RELEASE_CANDIDATE=${RELEASE_CANDIDATE}" > stagging.env
        - echo "VERSION=${VERSION}" >> stagging.env
    artifacts:
      reports:
        dotenv: stagging.env
    needs:
      - TestingApp        
    rules:
        - if: '$CI_COMMIT_BRANCH == "release" && $AMBIENTE == "QA"'

publish_image:
    stage: release
    image: docker:26.0.1
    services:
        - docker:20-dind
    variables:
      IMAGE: $CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG:$VERSION-QA
    needs:
        - Build
    script:
        - apk add --no-cache curl   git zip unzip
        - unzip build.zip
        - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
        - docker build -t $IMAGE .
        - docker push $IMAGE 
    after_script: 
        - echo "VERSION=${VERSION}" > VersionApp.env
        - cat VersionApp.env
    artifacts:
        reports:
            dotenv: VersionApp.env        
    rules:
        - if: '$CI_COMMIT_BRANCH == "release" && $AMBIENTE == "QA"'

deploy_qa:
    stage: deploy
    image: ubuntu:latest
    variables:
#      GIT_STRATEGY: none
      PEMFILE: /tmp/your-key.pem
      IMAGE: $CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG:$VERSION-QA
      SPRING_DATASOURCE_URL: ${DB_URL_QA} 
      SPRING_DATASOURCE_USERNAME: ${DB_USERNAME_QA} 
      SPRING_DATASOURCE_PASSWORD: ${DB_PASSWORD_QA} 
    before_script:
      - apt-get update && apt-get install -y openssh-client
      - echo "Decodificando la clave privada"
      - echo "$EC2_SSH_PRIVATE_KEY_BASE64" | base64 --decode > ${PEMFILE}
      - chmod 600 ${PEMFILE}
      - echo "Conect치ndose al servidor EC2" 
      - ssh -o StrictHostKeyChecking=no -i ${PEMFILE} ${EC2_USER_AWS}@${EC2_IP_SERVERFRONT} 'echo "Conexi칩n exitosa"'
    script:  
      - scp -o StrictHostKeyChecking=no -i /tmp/your-key.pem docker-compose.yml ${EC2_USER_AWS}@${EC2_IP_SERVERFRONT}:~/docker-compose.yml 
      - ssh -o StrictHostKeyChecking=no -i /tmp/your-key.pem ${EC2_USER_AWS}@${EC2_IP_SERVERFRONT} "echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY"
      - ssh -o StrictHostKeyChecking=no -i /tmp/your-key.pem ${EC2_USER_AWS}@${EC2_IP_SERVERFRONT} "echo VARS=DEPLOY > ~/front.env" 
      - ssh -o StrictHostKeyChecking=no -i /tmp/your-key.pem ${EC2_USER_AWS}@${EC2_IP_SERVERFRONT} "echo IMAGE=$IMAGE >> ~/front.env"
      - ssh -o StrictHostKeyChecking=no -i /tmp/your-key.pem ${EC2_USER_AWS}@${EC2_IP_SERVERFRONT} "docker compose  --env-file ~/front.env pull"
      - ssh -o StrictHostKeyChecking=no -i /tmp/your-key.pem ${EC2_USER_AWS}@${EC2_IP_SERVERFRONT} "docker compose  --env-file ~/front.env up -d" 
      - ssh -o StrictHostKeyChecking=no -i /tmp/your-key.pem ${EC2_USER_AWS}@${EC2_IP_SERVERFRONT} "docker ps"
      - ssh -o StrictHostKeyChecking=no -i /tmp/your-key.pem ${EC2_USER_AWS}@${EC2_IP_SERVERFRONT} "rm -fR ~/*" 
    rules:
        - if: '$CI_COMMIT_BRANCH == "release" && $AMBIENTE == "QA"'
    needs:
        - publish_image
    environment:
        name: QA Environment
        url: http://${EC2_IP_SERVERFRONT}
